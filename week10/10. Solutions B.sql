-- Task 01. -> classicmodels database
-- For every product in the order details table get the product code 
-- and calculate subtotal (quantity * price) for every product order 
-- where quantity is greater than 20 and price is less than 120. 
-- Round subtotal on two decimal places.
SELECT productCode, ROUND((SUM(quantityOrdered * priceEach)), 2) AS "Subtotal"
FROM orderdetails
WHERE quantityOrdered > 20 AND priceEach < 120
GROUP BY productCode;

-- Task 02. -> classicmodels database
-- Calculate the total sales (quantityOrdered * priceEach) for each employee,
-- including the employee's full name and total sales amount.
-- Only include employees who have managed sales above 150,000.
SELECT e.firstName, e.lastName, 
       SUM(od.quantityOrdered * od.priceEach) AS totalSales
FROM employees e
JOIN customers c ON e.employeeNumber = c.salesRepEmployeeNumber
JOIN orders o ON c.customerNumber = o.customerNumber
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY e.employeeNumber, e.firstName, e.lastName
HAVING totalSales > 150000
ORDER BY totalSales DESC;

-- Task 03. -> classicmodels database
-- For each product line, calculate the total number of orders
-- and the total quantity ordered. Include only product
-- lines with more than 200 orders.
SELECT p.productLine, 
       COUNT(DISTINCT o.orderNumber) AS totalOrders, 
       SUM(od.quantityOrdered) AS totalQuantity
FROM products p
JOIN orderdetails od ON p.productCode = od.productCode
JOIN orders o ON od.orderNumber = o.orderNumber
GROUP BY p.productLine
HAVING totalOrders > 200
ORDER BY totalOrders DESC;

-- Task 04. -> classicmodels database
-- Find the total sales (quantityOrdered * priceEach) for each product,
-- along with the product name and product line,
-- and include only products with total sales above 50,000.
SELECT p.productName, p.productLine, 
       SUM(od.quantityOrdered * od.priceEach) AS totalSales
FROM products p
JOIN orderdetails od ON p.productCode = od.productCode
JOIN orders o ON od.orderNumber = o.orderNumber
GROUP BY p.productName, p.productLine
HAVING totalSales > 50000
ORDER BY totalSales DESC;

-- Task 05. -> classicmodels database
-- Get the maximum, minimum, total, and average credit limit for all customers
-- in each country and each city where the country and city are not null.
-- Order the result set by country in descending order and by city in ascending order.
SELECT MAX(creditLimit) AS "Max credit limit", MIN(creditLimit) AS "Min credit limit",
       SUM(creditLimit) AS "Total credit limit", AVG(creditLimit) AS "Avg credit limit"
FROM customers
WHERE country IS NOT NULL AND city IS NOT NULL
GROUP BY country, city
ORDER BY country DESC, city ASC;

-- Task 02. -> sakila database
-- Write a query to count the number of films per rating for an actor Jennifer Davis.
-- Only include ratings where the actor has appeared in at least 5 films.
SELECT f.rating AS "Film rating", SUM(f.film_id) AS "Number of films"
FROM film f
JOIN film_actor fa ON f.film_id = fa.film_id
JOIN actor a ON fa.actor_id = a.actor_id 
WHERE a.first_name = "Jennifer" AND a.last_name = "Davis"
GROUP BY f.rating 
HAVING COUNT(f.film_id) >= 5;

-- Task 03. -> sakila database
-- Write a query to calculate the total revenue collected from rentals for each city.
-- Only include cities with a total revenue greater than $190.
-- Order result set by total_revenue in descending order.
SELECT SUM(p.amount) AS "Total revenue", ci.city
FROM city ci
JOIN address a on ci.city_id = a.city_id
JOIN customer c on a.address_id = c.address_id
JOIN payment p on c.customer_id = p.customer_id
GROUP BY ci.city_id
HAVING SUM(p.amount) > 190
ORDER BY SUM(p.amount) DESC;

-- Task 02. -> sakila database
-- Find the total revenue generated by each film category and
-- the total number of rentals. Only include categories 
-- where the total revenue exceeds $1000.
SELECT c.name AS categoryName, 
       SUM(p.amount) AS totalRevenue, 
       COUNT(r.rental_id) AS totalRentals
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id
JOIN film f ON fc.film_id = f.film_id
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.name
HAVING totalRevenue > 1000
ORDER BY totalRevenue DESC;

-- Task 04. -> employees database
-- Calculate the total number of employees for each department.
-- Order the result set by descending order.
SELECT d.dept_name, COUNT(de.emp_no) AS "Number of employees"
FROM departments d
JOIN dept_emp de ON d.dept_no = de.dept_no
GROUP BY d.dept_name
ORDER BY COUNT(de.emp_no) DESC;

-- Task 04. -> employees database
-- Write a query to identify the employee who has been in each department the longest.
-- Include the employee’s first name, last name, department name, and the duration of service in days.
SELECT d.dept_name, e.first_name, e.last_name,
      DATEDIFF(MAX(de.to_date), MIN(de.from_date)) AS duration_days
FROM departments d
JOIN dept_emp de ON d.dept_no = de.dept_no
JOIN employees e ON de.emp_no = e.emp_no
GROUP BY d.dept_name, e.emp_no
ORDER BY d.dept_name, duration_days DESC;

-- Task 04. -> employees database
--  Find the total salary expenditure for each department, along
-- with the department name. Only include departments with a total
-- salary expenditure exceeding $5,000,000.
SELECT d.dept_name, 
       SUM(s.salary) AS totalExpenditure
FROM departments d
JOIN dept_emp de ON d.dept_no = de.dept_no
JOIN salaries s ON de.emp_no = s.emp_no
GROUP BY d.dept_name
HAVING totalExpenditure > 5000000
ORDER BY totalExpenditure DESC;

-- Task 04. -> employees database
-- For each job title, calculate the total number of employees and the average salary.
-- Include only titles with more than 1,000 employees.
SELECT t.title, 
       COUNT(e.emp_no) AS totalEmployees, 
       AVG(s.salary) AS avgSalary
FROM titles t
JOIN employees e ON t.emp_no = e.emp_no
JOIN salaries s ON e.emp_no = s.emp_no
GROUP BY t.title
HAVING COUNT(e.emp_no) > 1000
ORDER BY totalEmployees DESC;

-- Task 04. -> employees database
-- Find the longest tenure (in days) of employees for each department,
-- along with the department name. Include only departments where the
-- longest tenure exceeds 5,000 days. Tenure refers to the number of days an employee worked.
SELECT d.dept_name, 
       MAX(DATEDIFF(de.to_date, de.from_date)) AS longestTenure
FROM departments d
JOIN dept_emp de ON d.dept_no = de.dept_no
GROUP BY d.dept_name
HAVING longestTenure > 5000
ORDER BY longestTenure DESC;

-- Task 04. -> employees database
-- Write a query to create a JSON array of employee details for each department.
-- The JSON object in the array should include the employee’s firstName, lastName,
-- title, hireDate, and salary. Only include employees whose last names contain the letter "x".
-- Display the department name and the JSON array of employee details for each department.
SELECT d.dept_name AS departmentName, 
       JSON_ARRAYAGG(
           JSON_OBJECT(
               'firstName', e.first_name,
               'lastName', e.last_name,
               'title', t.title,
               'hireDate', e.hire_date,
               'salary', s.salary
           )
       ) AS employeeDetails
FROM departments d
JOIN dept_emp de ON d.dept_no = de.dept_no
JOIN employees e ON de.emp_no = e.emp_no
JOIN titles t ON e.emp_no = t.emp_no
JOIN salaries s ON e.emp_no = s.emp_no
WHERE e.last_name LIKE '%x%'
GROUP BY d.dept_no, d.dept_name;